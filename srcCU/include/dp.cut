//File included in src/include/dp.cuh 
#ifndef DP_CUT
#define DP_CUT

#define THREADS 128

std::vector<Angle> bestAngles(DP::Cell* matrix, int discr, int size){
  DP::Cell* best=&matrix[0];
  //Find best path
  for (int i=size; i<discr*size; i+=size){
    if (best->l()>matrix[i].l()  && matrix[i].l()!=0){ //TODO The second check is actually a bug in solveCell, but I'm not in the right mind to find this bug, please fix later
      best=&matrix[i];
    }
  }
  //Retrieve best angles
  vector<Angle> ret(1, best->th());
  uint nextID=best->next();
  while (nextID!=0){
    ret.push_back(matrix[nextID].th());
    nextID=matrix[nextID].next();
  }
  return ret;
}

std::vector<Angle> bestAnglesMatrix(DP::Cell* matrix, int discr, int size, const std::vector<bool>& fixedAngles){
  DP::Cell* best=&matrix[0];

  if (!fixedAngles[0]){
    for(int i=1; i<discr; i++){
      if (matrix[i].l()<best->l())
        best=&matrix[i];
    }
  }

  vector<Angle> ret(1, best->th());
  uint nextID=best->next();
  while (nextID!=0){
    ret.push_back(matrix[nextID].th());
    nextID=matrix[nextID].next();
  }
  return ret;
}


template<class CURVE>
__global__ void solveCell(DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                          Configuration2<real_type> c0, Configuration2<real_type> c1, uint* bestK, LEN_T* bestL,
                          Angle* bestA, Angle a00, Angle a01, real_type* params, int i
                          ){
  int k=threadIdx.x+blockDim.x*blockIdx.x;
  if(k<discr){
    if (!fixedAngles[i]){ c1.th(a01+2*M_PI*k/(discr*1.0)); } //If angle is fixed I don't have to change it
    CURVE c=CURVE(c0, c1, params); 
    if (c.l()>0){
      DP::Cell* next=(i==size-1 ? NULL : &matrix[k*size+(i+1)]);
      LEN_T currL=c.l();
      if (next!=NULL){
        currL+=next->l();
      }  
        bestL[k]=currL;
        bestA[k]=c1.th();
        bestK[k]=k;
    }
  }
}

template<class CURVE>
__global__ void solveCol( DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                          Configuration2<real_type> c0, Configuration2<real_type> c1, 
                          Angle a00, Angle a01, real_type* params, int i
                        ){
  uint tidx=threadIdx.x+blockDim.x*blockIdx.x;
  uint stride=blockDim.x*gridDim.x;

  uint j=tidx;
  // if (j<discr){
  for (; j<discr; j+=stride){
    Angle bestA=0.0;
    LEN_T bestL=MAX_LEN_T; 
    int bestK=0;

    if (!fixedAngles[i-1]){ c0.th(a00+2*M_PI*j/(discr*1.0)); } //If angle is fixed I don't have to change it
    
    for (int k=0; k<discr; k++){ //SolveCell
      LEN_T currL=MAX_LEN_T;
      if (!fixedAngles[i]){ c1.th(a01+2*M_PI*k/(discr*1.0)); } //If angle is fixed I don't have to change it
      CURVE c=CURVE(c0, c1, params); 
      DP::Cell* next=(i==size-1 ? NULL : &matrix[k*size+(i+1)]);
      if (c.l()>0){
        currL=c.l();
        if (next!=NULL){
          currL+=next->l();
        }  
        if (currL<bestL || bestL==MAX_LEN_T){
          bestL=currL;
          bestA=c1.th();
          bestK=k;
        }
      }
      if (fixedAngles[i]){ k=discr; } //If the angle is fixed I don't have to change it
    }
    
    if (bestL!=MAX_LEN_T){
      Cell* next=(i==size-1? NULL : &matrix[bestK*size+(i+1)]);
      uint nextID=(i==size-1 ? 0 : bestK*size+(i+1));
      matrix[j*size+i]=Cell(bestA, bestL, nextID, i, j, j*size+i);
    }
    if (i==1){
      matrix[size*j]=Cell(c0.th(), bestL, (size*j+i), 0, j, size*j);
    }
    if(fixedAngles[i-1]) j=discr;
  }
}

template<class CURVE>
std::vector<Angle> solveDP (std::vector<Configuration2<real_type> > points, int discr, const std::vector<bool> fixedAngles, std::vector<real_type> params, bool guessInitialAnglesVal=false){
  cudaError_t err=cudaSuccess;
  int numberOfSMs; cudaDeviceGetAttribute(&numberOfSMs, cudaDevAttrMultiProcessorCount, cudaGetdeviceID());
  
  uint size=points.size();
  if (points.size()!=fixedAngles.size()){
    cerr << "Number of points and number of fixed angles are not the same: " << points.size() << "!=" << fixedAngles.size() << endl;
    return std::vector<Angle>();
  }
  if (guessInitialAnglesVal){
    DP::guessInitialAngles(points, fixedAngles);
  }
  DP::Cell* matrix=new DP::Cell[size*discr];
  DP::Cell* dev_matrix;
  cudaMalloc(&dev_matrix, sizeof(DP::Cell)*discr*size);
  cudaCheckError(cudaGetLastError());
  
  bool* dev_fixedAngles=cudaSTDVectorToArray<bool>(fixedAngles);
  real_type* dev_params=cudaSTDVectorToArray<real_type>(params);
  
  cudaCheckError(cudaGetLastError());
  
  for (int i=size-1; i>0; i--){
    Configuration2<real_type>c0=points[i-1];
    Configuration2<real_type>c1=points[i];
    Angle a00=c0.th(), a01=c1.th();
    size_t threads=discr>THREADS ? THREADS : discr;
    size_t blocks=numberOfSMs; 
    // size_t blocks=((int)(discr/threads)+1)*numberOfSMs; 
    if(fixedAngles[i-1]){
      threads=1;
      blocks=1;
    }
    solveCol<CURVE><<<blocks, threads>>>(dev_matrix, discr, size, dev_fixedAngles, c0, c1, a00, a01, dev_params, i);
    cudaDeviceSynchronize();
    cudaCheckError(cudaGetLastError());
  }

  cudaMemcpy(matrix, dev_matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyDeviceToHost);
  cudaCheckError(cudaGetLastError());

#ifdef DEBUG
  cout << "Printing " << endl;
  printVM(matrix, discr, size)
  //Retrieve angles
  cout << "Computing best angles" << endl;
#endif
  std::vector<Angle> bestA=DP::bestAngles(matrix, discr, size);
#ifdef DEBUG
  printV(bestA)
#endif
  
#ifdef DEBUG
  LEN_T Length=0.0;
  for (unsigned int i=bestA.size()-1; i>0; i--){
    points[i].th(bestA[i]);
    points[i-1].th(bestA[i-1]);
    CURVE c(points[i-1], points[i], params.data());
    Length+=c.l();
  }
  cout << "Length: " << setprecision(20) << Length << endl;

  cout << "Printing for Matlab" << endl;
  cout << "X=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].x() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "Y=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].y() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "th=[";
  for (unsigned int i=0; i<bestA.size(); i++){ cout << bestA[i] << (i!=bestA.size()-1 ? ", " : "];\n"); }
  cout << "KMAX: " << params[0] << endl;
#endif

  free(matrix);
  cudaFree(dev_matrix);
  cudaFree(dev_fixedAngles);
  cudaFree(dev_params);

  return bestA;
}

template<class CURVE> 
__global__ void solveMatrixCell ( DP::Cell* matrix, uint discr, Configuration2<real_type> c0, Configuration2<real_type> c1,
                                  real_type* params, int i, int j, real_type* results, uint* next_r){
    int h=threadIdx.x+blockDim.x*blockIdx.x;
    if (h<discr){
      c0.th(matrix[i*discr+j].th());
      c1.th(matrix[(i+1)*discr+h].th());

      CURVE c=CURVE(c0, c1, params);
      LEN_T currL=c.l()+matrix[(i+1)*discr+h].l();

      results[h]=currL;
      next_r[h]=(i+1)*discr+h;

      //if (currL<matrix[i*discr+j].l()){
      //  matrix[i*discr+j].l(currL);
      //  matrix[i*discr+j].next((i+1)*discr+h);
      //}
    }
}

template<class CURVE> 
__global__ void solveMatrixCol1 (DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                                Configuration2<real_type> c0, Configuration2<real_type> c1, 
                                real_type* params, int i){
  uint tidx=threadIdx.x+blockDim.x*blockIdx.x;
  uint stride=blockDim.x*gridDim.x;

  uint j=tidx;
  for (; j<discr; j+=stride){
    real_type* results=(real_type*)malloc(sizeof(real_type)*discr);
    uint* next_r=(uint*)malloc(sizeof(uint)*discr);
    size_t threads=THREADS;
    size_t blocks=(int)(discr/threads)+1;
    if (fixedAngles[i+1]) {
      threads=1;
      blocks=1;
    }

    solveMatrixCell<CURVE><<<blocks, threads>>>(matrix, discr, c0, c1, params, i, j, results, next_r);
    
    real_type bestL=MAX_LEN_T;
    int next_id=0;
    for (uint h=0; h<discr; h++){
      if (bestL>results[h]){
        bestL=results[h];
        next_id=next_r[h];
      }
    }
    if(bestL!=MAX_LEN_T){
      matrix[i*discr+j].l(bestL);
      matrix[i*discr+j].next(next_id);
    }

    free(results);
    free(next_r);

    if(fixedAngles[i]) j=discr;
  }
}

template<class CURVE> 
__global__ void solveMatrixCol (DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                                Configuration2<real_type> c0, Configuration2<real_type> c1, 
                                real_type* params, int i){
  uint tidx=threadIdx.x+blockDim.x*blockIdx.x;
  uint stride=blockDim.x*gridDim.x;

  uint j=tidx;
  // if (j<discr){
  for (; j<discr; j+=stride){
    for (uint h=0; h<discr; h++){
      c0.th(matrix[i*discr+j].th());
      c1.th(matrix[(i+1)*discr+h].th());

      CURVE c=CURVE(c0, c1, params);
      LEN_T currL=c.l()+matrix[(i+1)*discr+h].l();
      if (currL<matrix[i*discr+j].l()){
        matrix[i*discr+j].l(currL);
        matrix[i*discr+j].next((i+1)*discr+h);
      }
      if (fixedAngles[i+1]) {h=discr;}
    }
    if(fixedAngles[i]) j=discr;
  }
}

template<class CURVE>
std::vector<Angle> solveDPMatrix (std::vector<Configuration2<real_type> > points, int discr, const std::vector<bool> fixedAngles, std::vector<real_type> params, bool guessInitialAnglesVal=false){
  int numberOfSMs; cudaDeviceGetAttribute(&numberOfSMs, cudaDevAttrMultiProcessorCount, cudaGetdeviceID());
  uint addAngles=0;
  size_t size=points.size();

  if(guessInitialAnglesVal && addAngles>0){
    guessInitialAngles(points, fixedAngles);
  }

  DP::Cell* matrix;
  cudaMallocHost(&matrix, (sizeof(DP::Cell)*size*discr));
  DP::Cell* dev_matrix;
  cudaMalloc(&dev_matrix, sizeof(DP::Cell)*size*(discr+addAngles));
  
  bool* dev_fixedAngles=cudaSTDVectorToArray<bool>(fixedAngles);
  real_type* dev_params=cudaSTDVectorToArray<real_type>(params);  

  for (uint i=0; i<size; i++){ //TODO change back, remove l=-1 if fixedAngles
    LEN_T l = (i==size-1 ? 0 : std::numeric_limits<LEN_T>::max());
    for (uint j=0; j<discr; j++){
      if (fixedAngles[i]){
        matrix[i*discr+j]=DP::Cell(points[i].th(), (j==0 ? l : -1), 0, i, j, i*discr);

      }
      else {
        matrix[i*discr+j]=DP::Cell(2*M_PI*j/discr, l, 0, i, j, i*discr+j);
      }
    }
  }
  cudaMemcpy(dev_matrix, matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyHostToDevice);
  cudaCheckError(cudaGetLastError());

  for (int i=size-2; i>=0; i--){
    Configuration2<real_type> c0=points[i];
    Configuration2<real_type> c1=points[i+1];

    size_t threads=discr>THREADS ? THREADS : discr;
    //size_t blocks=numberOfSMs; 
    size_t nBlocksGivenThreads=(int)(discr/threads);
    size_t blocks=1;
    if (nBlocksGivenThreads>0 && nBlocksGivenThreads<numberOfSMs){
      blocks=nBlocksGivenThreads;
    }
    else if (nBlocksGivenThreads==0){
      blocks=1;
    }
    else{
      blocks=((int)(nBlocksGivenThreads/numberOfSMs))*numberOfSMs;
    }
    //size_t blocks=((int)(discr/threads)+1)*numberOfSMs; 
    if(fixedAngles[i]){
      threads=1;
      blocks=1;
    }
    solveMatrixCol<CURVE><<<blocks, threads>>>(dev_matrix, discr, size, dev_fixedAngles, c0, c1, dev_params, i);
    cudaDeviceSynchronize();
    cudaCheckError(cudaGetLastError());
  }
  cudaMemcpy(matrix, dev_matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyDeviceToHost);
  cudaCheckError(cudaGetLastError());

#ifdef DEBUG
  cout << "Printing " << endl;
  printVM(matrix, size, discr)
  //Retrieve angles
  cout << "Computing best angles" << endl;
#endif
  std::vector<Angle> bestA=DP::bestAnglesMatrix(matrix, discr, size, fixedAngles);
#ifdef DEBUG
  printV(bestA)
#endif
  
  LEN_T Length=0.0;
  for (unsigned int i=bestA.size()-1; i>0; i--){
    points[i].th(bestA[i]);
    points[i-1].th(bestA[i-1]);
    CURVE c(points[i-1], points[i], params.data());
    Length+=c.l();
  }
  cout << "Length: " << setprecision(20) << Length << endl;
#ifdef DEBUG
  cout << "Printing for Matlab" << endl;
  cout << "X=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].x() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "Y=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].y() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "th=[";
  for (unsigned int i=0; i<bestA.size(); i++){ cout << bestA[i] << (i!=bestA.size()-1 ? ", " : "];\n"); }
  cout << "KMAX: " << params[0] << endl;
#endif
  cudaFreeHost(matrix);

  cudaFree(dev_matrix);
  cudaFree(dev_params);
  cudaFree(dev_fixedAngles);

  return bestA;
}

template<class CURVE>
__global__ void computeMore(DP::Cell* matrix, real_type* results, const bool* fixedAngles,
                            real_type* params, const Configuration2<real_type>* points, 
                            size_t jump, size_t discr, size_t size, size_t iter){ //TODO It may be possible to remove cmp and use iter and i to compute the position
  uint tidx=threadIdx.x+blockDim.x*blockIdx.x;
  uint stride=blockDim.x*gridDim.x;

  uint j=tidx;
  if (j<discr*jump*discr){ //j must be less than the number of rows (jump) times the number of inner cells per cell, times the number of cells per row
    uint cell=(int)(tidx/discr);  //The big cell
    uint inCell=tidx%discr;       //The small cell insider the big cell
    uint cmpId=(int)(cell/discr); //The row in this call
    uint pos=iter*jump+cmpId;     //The row w.r.t. the whole matrix

    if (pos<size-1){ 
      Configuration2<real_type> c0=points[pos];
      Configuration2<real_type> c1=points[pos+1];

      if (!fixedAngles[pos])   {c0.th(matrix[cell+iter*jump*discr].th());}
      if (!fixedAngles[pos+1]) {c1.th(matrix[inCell+(pos+1)*discr].th());}

      CURVE c=CURVE(c0, c1, params);
      if (c.l()>0){
        results[cell*discr+inCell]=c.l();
      }
    }
  }
}

__global__ void bestAnglesPerCell(DP::Cell* matrix, real_type* results, const bool* fixedAngles, 
                                      size_t size, size_t discr, size_t iter, size_t jump){

  uint tidx=threadIdx.x+blockDim.x*blockIdx.x;
  uint i=tidx;
  if (i<discr){ //It would be soooooo beautiful to increase the performances of this
    for (int j=jump-1; j>=0; j--){
      LEN_T bestL=MAX_LEN_T;
      uint nextID=0;
      uint pos=((jump*iter+j)*discr+i)*discr;
      uint posRes=(i+j*discr)*discr;
      //printf("tidx: %u iter: %d jump: %d pos: %u\n", tidx, (int)iter, (int)jump, pos);
      for (int h=0; h<discr; h++){ //The inner cells of the row I'm considering
        if (((int)(pos/(discr*discr)))==(size-2) && results[posRes+h]<bestL){ //If it's the last row and the length is shorter than bestL, then
          //printf("[%u] %f, %f\n", pos, bestL, results[posRes+h]);
          bestL=results[posRes+h];
          nextID=iter*jump*discr+(j+1)*discr+h;
        }
        else if(((int)(pos/(discr*discr)))<(size-2)){ //Otherwise consider also the next length
          //printf("tidx: %u, pos: %u, j: %d h: %d, id: %u\n", tidx, pos, j, h, id);
          LEN_T currL=results[posRes+h]+matrix[iter*jump*discr+(j+1)*discr+h];
          if (currL<bestL){
            bestL=currL;
            //nextID=((iter+1)*discr*jump)*discr+l;
            nextID=iter*jump*discr+(j+1)*discr+h;
            //printf("[%u] %f and %f\n", pos, currL, bestL);
          }
          else{
            //printf("[%u] %f<%f\n", pos, currL, bestL);
          }
        }
      }
      if (((int)(pos/(discr*discr)))<(size-1)){
        //printf("[%u] Writing %f in %d\n", pos, bestL, (int)(pos/discr));
        matrix[(int)(pos/discr)]=DP::Cell(matrix[(int)(pos/discr)].th(), bestL, nextID, matrix[(int)(pos/discr)].i(), matrix[(int)(pos/discr)].j(), matrix[(int)(pos/discr)].id());
      }
    }
  }
}

template<class CURVE>
std::vector<Angle> solveDPAllIn1 (std::vector<Configuration2<real_type> > points, int discr, const std::vector<bool> fixedAngles, std::vector<real_type> params, bool guessInitialAnglesVal=false, size_t _jump=0){

  int numberOfSMs; cudaDeviceGetAttribute(&numberOfSMs, cudaDevAttrMultiProcessorCount, cudaGetdeviceID());
  uint addAngles=0;
  size_t size=points.size();

  if(guessInitialAnglesVal && addAngles>0){
    guessInitialAngles(points, fixedAngles);
  }

  DP::Cell* matrix;
  cudaMallocHost(&matrix, sizeof(DP::Cell)*size*discr);
  DP::Cell* dev_matrix;
  cudaMalloc(&dev_matrix, sizeof(DP::Cell)*size*(discr+addAngles));
  //real_type* results;
  //cudaMallocHost(&results, sizeof(real_type)*size*discr*discr);
  
  bool* dev_fixedAngles=cudaSTDVectorToArray<bool>(fixedAngles);
  real_type* dev_params=cudaSTDVectorToArray<real_type>(params);  
  Configuration2<real_type>* dev_points=cudaSTDVectorToArray<Configuration2<real_type> >(points);

  for (uint i=0; i<size; i++){
    LEN_T l = (i==size-1 ? 0 : std::numeric_limits<LEN_T>::max());
    for (uint j=0; j<discr; j++){
      if (fixedAngles[i]){
        matrix[i*discr+j]=DP::Cell(points[i].th(), l, 0, i, j, i*discr);
      }
      else {
        matrix[i*discr+j]=DP::Cell(2*M_PI*j/discr, l, 0, i, j, i*discr+j);
      }
    }
  }
  cudaMemcpy(dev_matrix, matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyHostToDevice);
  cudaCheckError(cudaGetLastError());

  size_t jump=(_jump==0 ? 3 : _jump);
  size_t iter=0;
  if ((size-1)%jump==0) { iter=(size-1)/jump; }
  else                  { iter=(size_t)(((size-1)+jump)/jump); }

  size_t totThreads=jump*discr*discr;
  size_t threads=totThreads>THREADS ? THREADS : totThreads;
  size_t blocks=((int)(totThreads/threads)+1)*numberOfSMs; 
  
  real_type *dev_results1, *dev_results2, *dev_resultsapp;
  cudaMalloc(&dev_results1, sizeof(real_type)*jump*discr*discr);
  cudaMalloc(&dev_results2, sizeof(real_type)*jump*discr*discr);
    
  for (int i=iter-1; i>=0; i--){  
    computeMore<CURVE><<<blocks, threads>>>(dev_matrix, dev_results1, dev_fixedAngles, dev_params, dev_points, jump, discr, size, i);
    cudaDeviceSynchronize();
    //cudaMemcpy(dev_results2, dev_results1, sizeof(real_type)*jump*discr*discr, cudaMemcpyDeviceToDevice);
    cudaCheckError(cudaGetLastError());
    
    dev_resultsapp=dev_results1;
    dev_results1=dev_results2;
    dev_results2=dev_resultsapp;

    bestAnglesPerCell<<<blocks, threads>>>(dev_matrix, dev_results2, dev_fixedAngles, size, discr, i, jump);

    #ifdef DEBUG
    cudaDeviceSynchronize();
    cudaCheckError(cudaGetLastError());
    
    printf("\n");
    printResults<<<1, 1>>>(dev_results2, discr, size);
    #endif
  }
  cudaMemcpy(matrix, dev_matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyDeviceToHost);
  cudaCheckError(cudaGetLastError());

#ifdef DEBUG
  cout << "Printing " << endl;
  printVM(matrix, size, discr)
  //Retrieve angles
  cout << "Computing best angles" << endl;
#endif
  std::vector<Angle> bestA=DP::bestAnglesMatrix(matrix, discr, size, fixedAngles);
#ifdef DEBUG
  printV(bestA)
#endif
  
  LEN_T Length=0.0;
  for (unsigned int i=bestA.size()-1; i>0; i--){
    points[i].th(bestA[i]);
    points[i-1].th(bestA[i-1]);
    CURVE c(points[i-1], points[i], params.data());
    Length+=c.l();
  }
  cout << "\tLength: " << setprecision(20) << Length << endl;
#ifdef DEBUG

  cout << "Printing for Matlab" << endl;
  cout << "X=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].x() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "Y=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].y() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "th=[";
  for (unsigned int i=0; i<bestA.size(); i++){ cout << bestA[i] << (i!=bestA.size()-1 ? ", " : "];\n"); }
  cout << "KMAX: " << params[0] << endl;
#endif
  cudaFreeHost(matrix);

  cudaFree(dev_matrix);
  cudaFree(dev_params);
  cudaFree(dev_fixedAngles);
  cudaFree(dev_points);
  cudaFree(dev_results1);
  cudaFree(dev_results2);

  return bestA;
}



#endif
