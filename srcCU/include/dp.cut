//File included in src/include/dp.cuh 
#ifndef DP_CUT
#define DP_CUT

#ifdef CIAO
#error ciao
#endif
std::vector<Angle> bestAngles(DP::Cell* matrix, int discr, int size){
  DP::Cell* best=&matrix[0];
  //Find best path
  for (int i=size; i<discr*size; i+=size){
    if (best->l()>matrix[i].l()  && matrix[i].l()!=0){ //TODO The second check is actually a bug in solveCell, but I'm not in the right mind to find this bug, please fix later
      best=&matrix[i];
    }
  }
  //Retrieve best angles
  vector<Angle> ret(1, best->th());
  uint nextID=best->next();
  while (nextID!=0){
    ret.push_back(matrix[nextID].th());
    nextID=matrix[nextID].next();
  }
  return ret;
}

template<class CURVE>
__global__ void solveCell(DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                          Configuration2<real_type> c0, Configuration2<real_type> c1, uint* bestK, LEN_T* bestL,
                          Angle* bestA, Angle a00, Angle a01, real_type* params, int i
                          ){
  int k=threadIdx.x+blockDim.x*blockIdx.x;
  if(k<discr){
    //printf("k: %d\n", k);
    //printf("discr %u\n", discr);
    //printf("size %u\n", size);
    //printf("c0.x() %f c0.y() %f c0.th() %f\n", c0.x(), c0.y(), c0.th());
    //printf("c1.x() %f c1.y() %f c1.th() %f\n", c1.x(), c1.y(), c1.th());
    //printf("bestL %f\n", *bestL);
    //printf("bestK %d\n", *bestK);
    //printf("bestA %d\n", *bestA);
    //printf("params %f\n", params[0]);
    //printf("i %d\n", i);
    //printf("\n");

    if (!fixedAngles[i]){ c1.th(a01+2*M_PI*k/(discr*1.0)); } //If angle is fixed I don't have to change it
    CURVE c=CURVE(c0, c1, params); 
    if (c.l()>0){
      DP::Cell* next=(i==size-1 ? NULL : &matrix[k*size+(i+1)]);
      LEN_T currL=c.l();
      if (next!=NULL){
        currL+=next->l();
      }  
      //if (currL<bestL[k] || *bestL==MAX_LEN_T){
        bestL[k]=currL;
        bestA[k]=c1.th();
        bestK[k]=k;
      //}
    }
    //if (fixedAngles[i]){ k=discr; } //If the angle is fixed I don't have to change it
  }
}

template<class CURVE>
__global__ void solveCol( DP::Cell* matrix, uint discr, uint size, const bool* fixedAngles, 
                          Configuration2<real_type> c0, Configuration2<real_type> c1, 
                          Angle a00, Angle a01, real_type* params, int i
                        ){
  int j=threadIdx.x+blockDim.x*blockIdx.x;
  
  if (j<discr){
    Angle bestA=0.0;
    LEN_T bestL=MAX_LEN_T; 
    int bestK=0;

    if (!fixedAngles[i-1]){ c0.th(a00+2*M_PI*j/(discr*1.0)); } //If angle is fixed I don't have to change it
    
    for (int k=0; k<discr; k++){ //SolveCell
      LEN_T currL=MAX_LEN_T;
      if (!fixedAngles[i]){ c1.th(a01+2*M_PI*k/(discr*1.0)); } //If angle is fixed I don't have to change it
      CURVE c=CURVE(c0, c1, params); 
      DP::Cell* next=(i==size-1 ? NULL : &matrix[k*size+(i+1)]);
      if (c.l()>0){
        currL=c.l();
        if (next!=NULL){
          currL+=next->l();
        }  
        if (currL<bestL || bestL==MAX_LEN_T){
          bestL=currL;
          bestA=c1.th();
          bestK=k;
        }
      }
      //printf("[%d] c.l(): %f bestL: %f\n", j, c.l(), bestL);
      if (fixedAngles[i]){ k=discr; } //If the angle is fixed I don't have to change it
    }
    
    if (bestL!=MAX_LEN_T){
      Cell* next=(i==size-1? NULL : &matrix[bestK*size+(i+1)]);
      uint nextID=(i==size-1 ? 0 : bestK*size+(i+1));
      //printf("[%d] id: %d bestL: %f\n", j, j*size+i, bestL);
      matrix[j*size+i]=Cell(bestA, bestL, nextID, i, j, j*size+i);
    }
    if (i==1){
      matrix[size*j]=Cell(c0.th(), bestL, (size*j+i), 0, j, size*j);
    }
  }

}

template<class CURVE>
std::vector<Angle> solveDP (std::vector<Configuration2<real_type> > points, int discr, const std::vector<bool> fixedAngles, std::vector<real_type> params, bool guessInitialAnglesVal=false){
  //discr=2;
  cudaError_t err=cudaSuccess;
  uint size=points.size();
  if (points.size()!=fixedAngles.size()){
    cerr << "Number of points and number of fixed angles are not the same: " << points.size() << "!=" << fixedAngles.size() << endl;
    return std::vector<Angle>();
  }
  if (guessInitialAnglesVal){
    DP::guessInitialAngles(points, fixedAngles);
  }
  DP::Cell* matrix=new DP::Cell[size*discr];
  DP::Cell* dev_matrix;
  cudaMalloc(&dev_matrix, sizeof(DP::Cell)*discr*size);
  cudaCheckError(cudaGetLastError());
  
  bool* dev_fixedAngles=cudaSTDVectorToArray<bool>(fixedAngles);
  real_type* dev_params=cudaSTDVectorToArray<real_type>(params);
  
  cudaCheckError(cudaGetLastError());
  
  for (int i=size-1; i>0; i--){
    Configuration2<real_type>c0=points[i-1];
    Configuration2<real_type>c1=points[i];
    Angle a00=c0.th(), a01=c1.th();
    size_t threads=discr>512 ? 512 : discr;
    size_t blocks=(int)(discr/threads)+1; 
    if(fixedAngles[i-1]){
      threads=1;
      blocks=1;
    }
    solveCol<CURVE><<<blocks, threads>>>(dev_matrix, discr, size, dev_fixedAngles, c0, c1, a00, a01, dev_params, i);
    cudaDeviceSynchronize();
    cudaCheckError(cudaGetLastError());
  }

  cudaMemcpy(matrix, dev_matrix, sizeof(DP::Cell)*size*discr, cudaMemcpyDeviceToHost);
  cudaCheckError(cudaGetLastError());

#ifdef DEBUG
  cout << "Printing " << endl;
  printVM(matrix, discr, size)
  //Retrieve angles
  cout << "Computing best angles" << endl;
#endif
  std::vector<Angle> bestA=DP::bestAngles(matrix, discr, size);
#ifdef DEBUG
  printV(bestA)
#endif
  
  LEN_T Length=0.0;
  for (unsigned int i=bestA.size()-1; i>0; i--){
    points[i].th(bestA[i]);
    points[i-1].th(bestA[i-1]);
    CURVE c(points[i-1], points[i], params.data());
    Length+=c.l();
  }
  cout << "Length: " << setprecision(20) << Length << endl;
#ifdef DEBUG

  cout << "Printing for Matlab" << endl;
  cout << "X=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].x() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "Y=[";
  for (unsigned int i=0; i<points.size(); i++){ cout << points[i].y() << (i!=points.size()-1 ? ", " : "];\n"); }
  cout << "th=[";
  for (unsigned int i=0; i<bestA.size(); i++){ cout << bestA[i] << (i!=bestA.size()-1 ? ", " : "];\n"); }
  cout << "KMAX: " << params[0] << endl;
#endif

  free(matrix);
  cudaFree(dev_matrix);
  cudaFree(dev_fixedAngles);
  cudaFree(dev_params);

  return bestA;
}

#endif
